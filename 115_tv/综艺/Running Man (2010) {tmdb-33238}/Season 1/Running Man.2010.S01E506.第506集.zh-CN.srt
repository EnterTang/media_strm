1
00:00:06,800 --> 00:00:13,650
自己设计出一个处理器是一件非常有意义的工作，

2
00:00:13,650 --> 00:00:22,030
那现在，我们离这个工作的目标只差最后一点点了， 而最后的这一步，又是非常关键的，

3
00:00:22,030 --> 00:00:30,590
那就是把我们之前所产生的这些控制信号集成起来， 并且，让这个处理器能够自动地工作。

4
00:00:35,570 --> 00:00:45,250
现在我们已经分析完了这个事例的指令系统中所有的指令，
我们也知道了每一条指令应该设置怎么样的控制信号，

5
00:00:45,250 --> 00:00:51,930
因此，我们现在就已经完成了这5个设计步骤当中的第4步，

6
00:00:51,930 --> 00:00:58,400
接下来我们要做的就是考虑如何集成这些控制信号，形成完整的控制逻辑。

7
00:00:59,510 --> 00:01:05,795
那我们先把之前的数据通路中的实现细节隐藏起来，就由一个方框

8
00:01:05,795 --> 00:01:12,080
来表示，那控制这个数据通路正常运转的控制信号，一共有这样8个，

9
00:01:12,080 --> 00:01:19,460
那这些控制信号是怎么产生的呢？还是要从来自指令存储器的指令编码开始说起。

10
00:01:19,460 --> 00:01:25,360
之前，我们已经从指令编码当中提取了若干的信号，作为数据通路的输入，

11
00:01:25,360 --> 00:01:31,260
但我们只要回忆一下指令格式就可以知道，还有两个位域，我们没有提及，

12
00:01:31,260 --> 00:01:38,820
这就是opcode和function，而正是这两个位域，是用来表明指令执行什么样-
的操作。

13
00:01:38,820 --> 00:01:43,960
因此，我们正是需要用这两个信号，来产生下面这些控制信号。

14
00:01:43,960 --> 00:01:52,050
实现这一部分功能的电路，就被称为控制逻辑，
也就是我们之前提到的控制器。要想知道控制逻辑

15
00:01:52,050 --> 00:01:56,160
是怎么实现的，我们还是先来看一个例子。

16
00:01:56,160 --> 00:02:03,330
我们以add指令为例，当我们取回一条指令的编码，如果是一条add指令，那它所需要

17
00:02:03,330 --> 00:02:10,500
执行的操作就是这两个，一是将两个寄存器当中的数相加，并保存到另一个寄存器当中，

18
00:02:10,500 --> 00:02:14,270
然后就将PC+4更新到PC寄存器当中。

19
00:02:14,270 --> 00:02:20,380
对于这条指令所需要的各个控制信号的值，我们之前也已经详细分析过。

20
00:02:20,380 --> 00:02:27,990
例如，这个RegDst信号应该为1，而RegWr信号也应该为1，

21
00:02:27,990 --> 00:02:31,460
又比如，这个MemtoReg信号应该为0。

22
00:02:31,460 --> 00:02:36,250
那我们把这些信号的值都摘出来，汇总成一张表格，

23
00:02:36,250 --> 00:02:44,250
在这张表中，就是执行这条add指令时，各个控制信号的值，而add指令

24
00:02:44,250 --> 00:02:49,380
对应的opcode域的值和function域的值，我们也列在上面。那用

25
00:02:49,380 --> 00:02:58,590
同样的方法，我们也可以列出减法指令所对应的所有控制信号的值，
以及其他指令各自对应的控制信号的值。

26
00:02:58,590 --> 00:03:06,200
这样，我们就得到了一张完整的表格，描述了每条指令和每个控制信号之间的关系。

27
00:03:06,200 --> 00:03:10,920
那刚才我们是用一列一列的方式得到了这张表格，

28
00:03:10,920 --> 00:03:18,220
然后我们换一个角度来看，如果按行来看，那我们就可以得到每一个控制信号的逻辑表达式，

29
00:03:18,220 --> 00:03:27,735
我们就以第一行这个RegDst信号为例，
那从这一行可以看出，只有当前指令是加法或者减法指令时，

30
00:03:27,735 --> 00:03:33,700
这个控制信号才需要为1，其他时候，都为0，就可以了。

31
00:03:33,700 --> 00:03:37,300
那我们可以把这个控制信号的逻辑表达式写出来，

32
00:03:37,300 --> 00:03:46,440
如果我们有一根信号标明现在是加法指令，即为add，
另而有根信号标明现在是减法指令，即为sub，

33
00:03:46,440 --> 00:03:52,230
那这个RegDst的控制信号就等于add和sub这两个信号进行或操作。

34
00:03:52,230 --> 00:03:56,990
那我们还得进一步分析，add和sub这两个信号应该如何生成。

35
00:03:56,990 --> 00:04:02,620
那我们先来看add指令的编码，add指令是一条R型指令，

36
00:04:02,620 --> 00:04:10,620
根据R型指令的位域划分，其opcode域都应该为0，而function域则指明-
了在R型

37
00:04:10,620 --> 00:04:15,910
指令当中，这细分的指令类别。因此，对于I的指令来说，

38
00:04:15,910 --> 00:04:21,200
就是opcode域为全0，而function域的第0位到第4位为0，

39
00:04:21,200 --> 00:04:30,010
第5位为1。这样一种信号的组合就代表了当前指令是add指令，
那我们就可以把add指令的逻辑表达式写出来。

40
00:04:30,010 --> 00:04:35,310
我们先用一根rtype信号，来表示当前是一个R型的

41
00:04:35,310 --> 00:04:43,690
指令，然后我们来看后面的信号，就是function域的第5位，
对于add指令来说，这一位应该为1，

42
00:04:43,690 --> 00:04:50,467
而function的第4位，一直到第0位，都应该为0， 所以我们将function

43
00:04:50,467 --> 00:04:58,820
0到4，每一位都先取非，
然后与function域的第5位，以及这个rtype信号，一起进行与操作，

44
00:04:58,820 --> 00:05:06,150
这样就可以得到了add信号。我们用类似的方法也可以得到sub这个信号。

45
00:05:06,150 --> 00:05:09,900
那么rtype这个信号又是如何产生呢？

46
00:05:09,900 --> 00:05:19,770
这非常地简单，因为R型指令就是opcode全为0，
所以我们只需要把opcode中的每一位都先取非，然后进行与操作，

47
00:05:19,770 --> 00:05:25,110
那么当opcode全为0时，这个rtype信号就会为1。

48
00:05:25,110 --> 00:05:32,340
我们把这些逻辑表达式连起来，就可以得到了RegDst这个控制信号的逻辑表达式，

49
00:05:32,340 --> 00:05:39,370
有了这样的逻辑表达式，我们就可以用与门和非门画出产生这个控制信号的电路图来，

50
00:05:39,370 --> 00:05:44,760
这样，对于这一个控制信号来说，它的控制逻辑就已经是确定的了。

51
00:05:44,760 --> 00:05:50,800
那我们用同样的方法还可以得到其他控制信号的逻辑表达式，

52
00:05:50,800 --> 00:05:56,695
例如ALUSrc这个信号，我们通过查询刚才的表格，可以知道，它是在

53
00:05:56,695 --> 00:06:02,590
ori指令、load指令和store指令，这三条指令执行时是有效的。

54
00:06:02,590 --> 00:06:08,915
因此我们注意下面，我们只要用类似的方法得到ori、load和store，

55
00:06:08,915 --> 00:06:15,240
这三条指令对应的逻辑表达式，我们就可以得到ALUSrc这个控制信号的逻辑表达式了。

56
00:06:15,240 --> 00:06:19,670
类似地，我们就可以得到所有控制信号的逻辑表达式。

57
00:06:19,670 --> 00:06:25,740
那我们注意到，在下面这个区域，所有的信号都是来自指定的编码了，

58
00:06:25,740 --> 00:06:32,225
而且，在对一些信号进行取非操作之后，这些逻辑表达式全都只有与操作，

59
00:06:32,225 --> 00:06:38,710
而上面这个区域的表达式都是在下面这些信号的基础上，进行了或操作，

60
00:06:38,710 --> 00:06:45,350
从而产生了最终的控制信号。因此，我们可以画出这样的一个控制器的示意图。

61
00:06:45,350 --> 00:06:54,460
我们把指令编码中opcode的这六位和function的这六位
连出来，先接到一组由与门构成的逻辑电路中。

62
00:06:54,460 --> 00:07:03,080
那么这一个逻辑电路就实现了上一页中，下面这片
区域的那些表达式，从而产生了一组中间信号，

63
00:07:03,080 --> 00:07:12,840
那么再将这些信号接入一组由或门组成的逻辑电路，这组
逻辑电路就实现了上一页中上半部分那些逻辑表达式，

64
00:07:12,840 --> 00:07:17,540
最后又可以得到了我们想要的所有的控制信号。

65
00:07:17,540 --> 00:07:24,930
那么这些逻辑电路就是我们刚才所提到的控制逻辑， 这样我们就有了控制器的实现。

66
00:07:24,930 --> 00:07:32,560
在这样的电路实现下，我们固定地将取回指令的最高六位和最低六位，连接到控制逻辑中，

67
00:07:32,560 --> 00:07:38,060
那经过了这些与门和或门之后，就会自动地生成对应的控制信号，

68
00:07:38,060 --> 00:07:43,550
而这些控制信号的值，肯定符合我们刚才对每条指令分析的需求，

69
00:07:43,550 --> 00:07:53,120
这样在指令执行的过程中，就不需要任何智力因素的介入，
去分析当前到底是什么指令，以及需要产生什么样的控制信号，

70
00:07:53,120 --> 00:08:02,650
一切都是通过这样的控制逻辑电路自动生成的，
这样，处理器就能一条接一条地取回指令，自动地执行下去。

71
00:08:04,860 --> 00:08:14,810
那好，现在我们已经完成了控制信号的集成，并形成了完整的控制逻辑电路，
这最后一步工作，我们也就已经完成了。

72
00:08:23,460 --> 00:08:31,020
现在，我们已经完成了一个处理器结构设计的步骤了，

73
00:08:31,020 --> 00:08:37,260
虽然这个处理器只是单周期的，而且也只支持6条指令，

74
00:08:37,260 --> 00:08:42,040
非常地简单，但是它确实是一个可以使用的处理器了。

75
00:08:42,040 --> 00:08:49,240
如果你有兴趣，还可以继续深入到物理设计的环节，把它真正地制造出来。


